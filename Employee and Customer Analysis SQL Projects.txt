Ecommerce Analysis Project
CREATE DATABASE ecommerce_analysis;
USE ecommerce_analysis;
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    city VARCHAR(50),
    country VARCHAR(50),
    registration_date DATE,
    customer_segment VARCHAR(20)
);		
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100),
    category VARCHAR(50),
    subcategory VARCHAR(50),
    price DECIMAL(10,2),
    cost_price DECIMAL(10,2),
    supplier VARCHAR(50)
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    order_date DATE,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),
    shipping_city VARCHAR(50),
    payment_method VARCHAR(cdffcfgvgg20)
);

CREATE TABLE order_items (
    order_item_id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    product_id INT,
    quantity INT,
    unit_price DECIMAL(10,2),
    discount DECIMAL(10,2),
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
INSERT INTO customers VALUES
(1, 'John', 'Doe', 'john.doe@email.com', 'New York', 'USA', '2023-01-15', 'Premium'),
(2, 'Sarah', 'Smith', 'sarah.smith@email.com', 'London', 'UK', '2023-02-20', 'Standard'),
(3, 'Mike', 'Johnson', 'mike.johnson@email.com', 'Paris', 'France', '2023-03-10', 'Premium'),
(4, 'Emily', 'Brown', 'emily.brown@email.com', 'Tokyo', 'Japan', '2023-01-05', 'Standard'),
(5, 'David', 'Wilson', 'david.wilson@email.com', 'Sydney', 'Australia', '2023-04-12', 'Premium'),
(6, 'Lisa', 'Taylor', 'lisa.taylor@email.com', 'New York', 'USA', '2023-05-10', 'Standard'),
(7, 'Robert', 'Chen', 'robert.chen@email.com', 'Tokyo', 'Japan', '2023-06-15', 'Premium'),
(8, 'Maria', 'Garcia', 'maria.garcia@email.com', 'London', 'UK', '2023-07-20', 'Standard');

INSERT INTO products VALUES
(1, 'MacBook Pro 16"', 'Electronics', 'Laptops', 2399.99, 1800.00, 'Apple Inc'),
(2, 'iPhone 15 Pro', 'Electronics', 'Smartphones', 1199.99, 900.00, 'Apple Inc'),
(3, 'Coffee Maker', 'Home Appliances', 'Kitchen', 149.99, 100.00, 'KitchenCo'),
(4, 'Running Shoes', 'Sports', 'Footwear', 129.99, 80.00, 'SportGear'),
(5, 'Desk Lamp', 'Home Decor', 'Lighting', 45.00, 25.00, 'HomeStyle'),
(6, 'Yoga Mat', 'Sports', 'Fitness', 29.99, 15.00, 'SportGear'),
(7, 'Wireless Headphones', 'Electronics', 'Audio', 199.99, 120.00, 'AudioTech'),
(8, 'Office Chair', 'Furniture', 'Chairs', 299.99, 180.00, 'FurnitureCo');

INSERT INTO orders VALUES
(1, 1, '2024-01-15', 'Delivered', 2399.99, 'New York', 'Credit Card'),
(2, 2, '2024-01-16', 'Delivered', 129.99, 'London', 'PayPal'),
(3, 3, '2024-01-17', 'Processing', 149.99, 'Paris', 'Credit Card'),
(4, 1, '2024-01-18', 'Delivered', 1199.99, 'New York', 'Credit Card'),
(5, 4, '2024-01-19', 'Delivered', 199.99, 'Tokyo', 'PayPal'),
(6, 5, '2024-01-20', 'Shipped', 299.99, 'Sydney', 'Credit Card'),
(7, 2, '2024-01-21', 'Delivered', 45.00, 'London', 'PayPal'),
(8, 6, '2024-01-22', 'Processing', 29.99, 'New York', 'Credit Card'),
(9, 7, '2024-01-23', 'Delivered', 2399.99, 'Tokyo', 'Credit Card'),
(10, 8, '2024-01-24', 'Shipped', 129.99, 'London', 'PayPal');

INSERT INTO order_items VALUES
(1, 1, 1, 1, 2399.99, 0),
(2, 2, 4, 1, 129.99, 0),
(3, 3, 3, 1, 149.99, 0),
(4, 4, 2, 1, 1199.99, 0),
(5, 5, 7, 1, 199.99, 0),
(6, 6, 8, 1, 299.99, 0),
(7, 7, 5, 1, 45.00, 0),
(8, 8, 6, 1, 29.99, 0),
(9, 9, 1, 1, 2399.99, 0),
(10, 10, 4, 1, 129.99, 0);

Question 1: Top 10 products by revenue and quantity sold
WITH product_sales AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.category,
        p.subcategory,
        COUNT(oi.order_id) AS times_ordered,
        SUM(oi.quantity) AS total_quantity_sold,
        SUM(oi.quantity * oi.unit_price) AS total_revenue,
        AVG(oi.unit_price) AS avg_selling_price
    FROM products p
    LEFT JOIN order_items oi ON p.product_id = oi.product_id
    LEFT JOIN orders o ON oi.order_id = o.order_id
    WHERE o.status != 'Cancelled' OR o.status IS NULL
    GROUP BY p.product_id, p.product_name, p.category, p.subcategory
)
SELECT 
    product_name,
    category,
    subcategory,
    times_ordered,
    total_quantity_sold,
    total_revenue,
    avg_selling_price,
    ROUND((total_revenue / SUM(total_revenue) OVER()) * 100, 2) AS revenue_percentage
FROM product_sales
ORDER BY total_revenue DESC
LIMIT 10;

Question 2: Monthly Revenue Trend
WITH monthly_revenue AS (
    SELECT 
        DATE_FORMAT(o.order_date, '%Y-%m') AS month_year,
        COUNT(DISTINCT o.order_id) AS order_count,
        COUNT(DISTINCT o.customer_id) AS customer_count,
        SUM(oi.quantity * oi.unit_price) AS monthly_revenue,
        AVG(oi.quantity * oi.unit_price) AS avg_order_value
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.status IN ('Delivered', 'Shipped')
    GROUP BY DATE_FORMAT(o.order_date, '%Y-%m')
)
SELECT 
    month_year,
    order_count,
    customer_count,
    monthly_revenue,
    avg_order_value,
    LAG(monthly_revenue) OVER (ORDER BY month_year) AS prev_month_revenue,
    ROUND(
        (monthly_revenue - LAG(monthly_revenue) OVER (ORDER BY month_year)) * 100.0 / 
        LAG(monthly_revenue) OVER (ORDER BY month_year), 
        2
    ) AS revenue_growth_percentage,
    SUM(monthly_revenue) OVER (
        ORDER BY month_year 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_revenue
FROM monthly_revenue
ORDER BY month_year;

Question 3: Top 5 Customers by Total Spending
WITH customer_spending AS (
    SELECT 
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        c.city,
        c.country,
        c.customer_segment,
        c.registration_date,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(oi.quantity * oi.unit_price) AS total_spent,
        AVG(oi.quantity * oi.unit_price) AS avg_order_value,
        MAX(o.order_date) AS last_order_date,
        MIN(o.order_date) AS first_order_date
    FROM customers c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.status IN ('Delivered', 'Shipped') OR o.status IS NULL
    GROUP BY c.customer_id, c.first_name, c.last_name, c.city, c.country, c.customer_segment, c.registration_date
),
ranked_customers AS (
    SELECT 
        *,
        RANK() OVER (ORDER BY total_spent DESC) AS spending_rank,
        PERCENT_RANK() OVER (ORDER BY total_spent) AS spending_percentile
    FROM customer_spending
)
SELECT 
    customer_name,
    city,
    country,
    customer_segment,
    total_orders,
    total_spent,
    avg_order_value,
    first_order_date,
    last_order_date,
    spending_rank,
    ROUND(spending_percentile * 100, 2) AS spending_percentile,
    CASE 
        WHEN total_spent > 2000 THEN 'VIP'
        WHEN total_spent > 1000 THEN 'Premium'
        WHEN total_spent > 500 THEN 'Regular'
        ELSE 'Standard'
    END AS value_tier
FROM ranked_customers
WHERE spending_rank <= 5
ORDER BY spending_rank;

Question 4: Running Total of Sales by Day
WITH daily_sales AS (
    SELECT 
        o.order_date,
        COUNT(DISTINCT o.order_id) AS daily_orders,
        COUNT(DISTINCT o.customer_id) AS daily_customers,
        SUM(oi.quantity) AS daily_units_sold,
        SUM(oi.quantity * oi.unit_price) AS daily_revenue,
        AVG(oi.quantity * oi.unit_price) AS avg_daily_order_value
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.status IN ('Delivered', 'Shipped')
    GROUP BY o.order_date
)
SELECT 
    order_date,
    daily_orders,
    daily_customers,
    daily_units_sold,
    daily_revenue,
    avg_daily_order_value,
    -- Running totals
    SUM(daily_revenue) OVER (
        ORDER BY order_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total_revenue,
    SUM(daily_orders) OVER (
        ORDER BY order_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total_orders,
    -- Moving averages
    AVG(daily_revenue) OVER (
        ORDER BY order_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS weekly_moving_avg_revenue,
    -- Day-over-day growth
    LAG(daily_revenue) OVER (ORDER BY order_date) AS prev_day_revenue,
    ROUND(
        (daily_revenue - LAG(daily_revenue) OVER (ORDER BY order_date)) * 100.0 / 
        NULLIF(LAG(daily_revenue) OVER (ORDER BY order_date), 0), 
        2
    ) AS daily_growth_percentage
FROM daily_sales
ORDER BY order_date;

Question 5: Customers who Havenâ€™t Purchased in the Last 30 Days
WITH customer_last_purchase AS (
    SELECT 
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        c.email,
        c.city,
        c.country,
        c.registration_date,
        c.customer_segment,
        MAX(o.order_date) AS last_purchase_date,
        COUNT(o.order_id) AS total_orders,
        COALESCE(SUM(oi.quantity * oi.unit_price), 0) AS lifetime_value,
        DATEDIFF(CURDATE(), MAX(o.order_date)) AS days_since_last_purchase
    FROM customers c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY c.customer_id, c.first_name, c.last_name, c.email, c.city, c.country, c.registration_date, c.customer_segment
)
SELECT 
    customer_id,
    customer_name,
    email,
    city,
    country,
    registration_date,
    customer_segment,
    last_purchase_date,
    total_orders,
    lifetime_value,
    days_since_last_purchase,
    CASE 
        WHEN days_since_last_purchase BETWEEN 30 AND 60 THEN 'At Risk'
        WHEN days_since_last_purchase BETWEEN 61 AND 90 THEN 'Dormant'
        WHEN days_since_last_purchase > 90 THEN 'Lost'
        ELSE 'Active'
    END AS customer_status
FROM customer_last_purchase
WHERE last_purchase_date IS NULL 
    OR last_purchase_date < DATE_SUB(CURDATE(), INTERVAL 30 DAY)
ORDER BY days_since_last_purchase DESC, lifetime_value DESC;

Employee Analysis Project
CREATE DATABASE employee_analysis;
USE employee_analysis;

Departments table
CREATE TABLE departments (
    dept_id INT PRIMARY KEY AUTO_INCREMENT,
    dept_name VARCHAR(50) NOT NULL,
    location VARCHAR(50),
    budget DECIMAL(12,2)
);

-- Employees table
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    hire_date DATE,
    department_id INT,
    job_title VARCHAR(50),
    salary DECIMAL(10,2),
    commission_pct DECIMAL(5,2),
    manager_id INT,
    performance_rating INT,
    FOREIGN KEY (department_id) REFERENCES departments(dept_id)
);

-- Insert sample data
INSERT INTO departments VALUES
(1, 'Engineering', 'New York', 5000000.00),
(2, 'Sales', 'London', 3000000.00),
(3, 'Marketing', 'Paris', 2000000.00),
(4, 'HR', 'Tokyo', 1000000.00),
(5, 'Finance', 'Sydney', 1500000.00);

INSERT INTO employees VALUES
(1, 'John', 'Smith', 'john.smith@company.com', '2020-01-15', 1, 'Senior Engineer', 120000, 0.00, NULL, 4),
(2, 'Sarah', 'Johnson', 'sarah.johnson@company.com', '2019-03-20', 2, 'Sales Manager', 95000, 0.10, NULL, 5),
(3, 'Mike', 'Brown', 'mike.brown@company.com', '2021-11-10', 1, 'Software Engineer', 90000, 0.00, 1, 3),
(4, 'Emily', 'Davis', 'emily.davis@company.com', '2022-02-01', 4, 'HR Specialist', 65000, 0.00, NULL, 4),
(5, 'David', 'Wilson', 'david.wilson@company.com', '2018-07-15', 2, 'Sales Executive', 80000, 0.15, 2, 5),
(6, 'Lisa', 'Taylor', 'lisa.taylor@company.com', '2021-05-10', 3, 'Marketing Manager', 110000, 0.00, NULL, 4),
(7, 'Robert', 'Chen', 'robert.chen@company.com', '2020-06-15', 5, 'Financial Analyst', 85000, 0.00, NULL, 3),
(8, 'Maria', 'Garcia', 'maria.garcia@company.com', '2019-07-20', 2, 'Sales Executive', 82000, 0.12, 2, 4),
(9, 'James', 'Miller', 'james.miller@company.com', '2022-08-01', 1, 'Junior Engineer', 75000, 0.00, 1, 3),
(10, 'Jennifer', 'Lee', 'jennifer.lee@company.com', '2021-09-15', 3, 'Marketing Specialist', 70000, 0.00, 6, 4);

Question 1: Average Salary by Department
WITH department_stats AS (
    SELECT 
        d.dept_id,
        d.dept_name,
        d.location,
        d.budget,
        COUNT(e.emp_id) AS employee_count,
        ROUND(AVG(e.salary), 2) AS avg_salary,
        MIN(e.salary) AS min_salary,
        MAX(e.salary) AS max_salary,
        SUM(e.salary) AS total_salary_budget,
        ROUND(STDDEV(e.salary), 2) AS salary_std_dev,
        ROUND(AVG(e.performance_rating), 2) AS avg_performance_rating
    FROM departments d
    LEFT JOIN employees e ON d.dept_id = e.department_id
    GROUP BY d.dept_id, d.dept_name, d.location, d.budget
),
department_ranks AS (
    SELECT 
        *,
        RANK() OVER (ORDER BY avg_salary DESC) AS salary_rank,
        RANK() OVER (ORDER BY avg_performance_rating DESC) AS performance_rank,
        ROUND((total_salary_budget / budget) * 100, 2) AS budget_utilization_percent
    FROM department_stats
)
SELECT 
    dept_name,
    location,
    employee_count,
    avg_salary,
    min_salary,
    max_salary,
    max_salary - min_salary AS salary_range,
    salary_std_dev,
    total_salary_budget,
    budget,
    budget_utilization_percent,
    avg_performance_rating,
    salary_rank,
    performance_rank,
    CASE 
        WHEN avg_salary > 100000 THEN 'High Paying'
        WHEN avg_salary > 80000 THEN 'Medium Paying'
        ELSE 'Standard Paying'
    END AS salary_tier
FROM department_ranks
ORDER BY avg_salary DESC;

Question 2: Employee with Highest Salary in Each Department
WITH department_top_earners AS (
    SELECT 
        e.emp_id,
        e.first_name,
        e.last_name,
        e.job_title,
        e.salary,
        e.hire_date,
        e.performance_rating,
        d.dept_name,
        d.location,
        RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC) AS dept_salary_rank,
        RANK() OVER (PARTITION BY e.department_id ORDER BY e.performance_rating DESC) AS dept_performance_rank,
        AVG(e.salary) OVER (PARTITION BY e.department_id) AS dept_avg_salary,
        MAX(e.salary) OVER (PARTITION BY e.department_id) AS dept_max_salary
    FROM employees e
    JOIN departments d ON e.department_id = d.dept_id
),
top_earners AS (
    SELECT *
    FROM department_top_earners
    WHERE dept_salary_rank = 1
),
company_metrics AS (
    SELECT 
        AVG(salary) AS company_avg_salary,
        MAX(salary) AS company_max_salary
    FROM employees
)
SELECT 
    te.emp_id,
    te.first_name,
    te.last_name,
    te.job_title,
    te.dept_name,
    te.location,
    te.salary,
    te.dept_avg_salary,
    te.dept_max_salary,
    cm.company_avg_salary,
    cm.company_max_salary,
    te.performance_rating,
    te.dept_performance_rank,
    te.hire_date,
    DATEDIFF(CURDATE(), te.hire_date) AS days_employed,
    -- Salary comparisons
    ROUND(te.salary - te.dept_avg_salary, 2) AS above_dept_avg,
    ROUND((te.salary - te.dept_avg_salary) * 100.0 / te.dept_avg_salary, 2) AS above_dept_avg_percent,
    ROUND(te.salary - cm.company_avg_salary, 2) AS above_company_avg,
    ROUND((te.salary - cm.company_avg_salary) * 100.0 / cm.company_avg_salary, 2) AS above_company_avg_percent,
    -- Compensation analysis
    CASE 
        WHEN te.salary > cm.company_avg_salary * 1.5 THEN 'Executive Level'
        WHEN te.salary > cm.company_avg_salary * 1.2 THEN 'Senior Level'
        WHEN te.salary > cm.company_avg_salary THEN 'Above Average'
        ELSE 'Standard'
    END AS compensation_tier
FROM top_earners te
CROSS JOIN company_metrics cm
ORDER BY te.salary DESC;

Question 3: Salary Difference between Each Employee and Department Average
-- Comprehensive employee salary analysis with department comparisons
WITH department_aggregates AS (
    SELECT 
        department_id,
        COUNT(*) AS dept_employee_count,
        ROUND(AVG(salary), 2) AS dept_avg_salary,
        MIN(salary) AS dept_min_salary,
        MAX(salary) AS dept_max_salary,
        ROUND(STDDEV(salary), 2) AS dept_salary_std_dev,
        ROUND(AVG(performance_rating), 2) AS dept_avg_performance
    FROM employees
    GROUP BY department_id
),
employee_analysis AS (
    SELECT 
        e.emp_id,
        CONCAT(e.first_name, ' ', e.last_name) AS employee_name,
        e.job_title,
        e.hire_date,
        e.salary,
        e.performance_rating,
        d.dept_name,
        d.location,
        da.dept_employee_count,
        da.dept_avg_salary,
        da.dept_min_salary,
        da.dept_max_salary,
        da.dept_salary_std_dev,
        da.dept_avg_performance,
        -- Salary comparisons
        ROUND(e.salary - da.dept_avg_salary, 2) AS salary_difference,
        ROUND((e.salary - da.dept_avg_salary) * 100.0 / da.dept_avg_salary, 2) AS salary_difference_percent,
        -- Z-score for salary within department
        ROUND((e.salary - da.dept_avg_salary) / NULLIF(da.dept_salary_std_dev, 0), 2) AS salary_z_score,
        -- Performance comparisons
        e.performance_rating - da.dept_avg_performance AS performance_difference,
        -- Tenure
        DATEDIFF(CURDATE(), e.hire_date) AS tenure_days,
        ROUND(DATEDIFF(CURDATE(), e.hire_date) / 365.25, 2) AS tenure_years,
        -- Rankings
        RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC) AS dept_salary_rank,
        RANK() OVER (PARTITION BY e.department_id ORDER BY e.performance_rating DESC) AS dept_performance_rank,
        PERCENT_RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary) AS dept_salary_percentile
    FROM employees e
    JOIN departments d ON e.department_id = d.dept_id
    JOIN department_aggregates da ON e.department_id = da.department_id
)
SELECT 
    employee_name,
    job_title,
    dept_name,
    location,
    salary,
    dept_avg_salary,
    salary_difference,
    salary_difference_percent,
    salary_z_score,
    performance_rating,
    dept_avg_performance,
    performance_difference,
    tenure_years,
    dept_salary_rank,
    dept_performance_rank,
    ROUND(dept_salary_percentile * 100, 2) AS dept_salary_percentile,
    -- Analysis categories
    CASE 
        WHEN salary_difference_percent > 20 THEN 'Significantly Above Average'
        WHEN salary_difference_percent > 10 THEN 'Above Average'
        WHEN salary_difference_percent > -10 THEN 'Average'
        WHEN salary_difference_percent > -20 THEN 'Below Average'
        ELSE 'Significantly Below Average'
    END AS salary_position,
    CASE 
        WHEN salary_z_score > 1.5 THEN 'Outlier High'
        WHEN salary_z_score > 0.5 THEN 'Above Mean'
        WHEN salary_z_score > -0.5 THEN 'Around Mean'
        WHEN salary_z_score > -1.5 THEN 'Below Mean'
        ELSE 'Outlier Low'
    END AS salary_distribution,
    -- Compensation fairness indicator
    CASE 
        WHEN performance_rating > dept_avg_performance AND salary_difference_percent > 0 THEN 'Fairly Compensated'
        WHEN performance_rating < dept_avg_performance AND salary_difference_percent < 0 THEN 'Fairly Compensated'
        WHEN performance_rating > dept_avg_performance AND salary_difference_percent < 0 THEN 'Potential Underpaid'
        WHEN performance_rating < dept_avg_performance AND salary_difference_percent > 0 THEN 'Potential Overpaid'
        ELSE 'Needs Review'
    END AS compensation_fairness
FROM employee_analysis
ORDER BY dept_name, salary DESC;

